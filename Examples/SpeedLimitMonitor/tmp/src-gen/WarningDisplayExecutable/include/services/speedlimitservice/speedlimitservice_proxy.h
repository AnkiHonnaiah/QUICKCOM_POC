/**********************************************************************************************************************
 *  COPYRIGHT
 *  -------------------------------------------------------------------------------------------------------------------
 *  \verbatim
 *  Copyright (c) 2025 by Vector Informatik GmbH. All rights reserved.
 *
 *                This software is copyright protected and proprietary to Vector Informatik GmbH.
 *                Vector Informatik GmbH grants to you only those rights as set out in the license conditions.
 *                All other rights remain with Vector Informatik GmbH.
 *  \endverbatim
 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -----------------------------------------------------------------------------------------------------------------*/
/**        \file  WarningDisplayExecutable/include/services/speedlimitservice/speedlimitservice_proxy.h
 *        \brief  Proxy for service 'SpeedLimitService'.
 *
 *      \details
 *
 *********************************************************************************************************************/
/**********************************************************************************************************************
 *  GENERATOR INFORMATION
 *  -------------------------------------------------------------------------------------------------------------------
 *    Generator Name: amsr_socal
 *         Commit ID: ad694a8ff64fb52ed9a0b9551cf05c10d499927a
 *********************************************************************************************************************/

#ifndef WARNINGDISPLAYEXECUTABLE_INCLUDE_SERVICES_SPEEDLIMITSERVICE_SPEEDLIMITSERVICE_PROXY_H_
#define WARNINGDISPLAYEXECUTABLE_INCLUDE_SERVICES_SPEEDLIMITSERVICE_SPEEDLIMITSERVICE_PROXY_H_

/*!
 * \trace SPEC-4980240
 */
/**********************************************************************************************************************
 *  INCLUDES
 *********************************************************************************************************************/
#include "amsr/socal/definitions.h"
#include "amsr/socal/events/proxy_event.h"
#include "amsr/socal/fields/proxy_field.h"
#include "amsr/socal/internal/events/proxy_event_backend_interface.h"
#include "amsr/socal/internal/logging/ara_com_logger.h"
#include "amsr/socal/methods/proxy_method.h"
#include "amsr/socal/thread_driven_proxy.h"
#include "services/speedlimitservice/SpeedLimitService_proxy_backend_interface.h"
#include "services/speedlimitservice/SpeedLimitService_types.h"
#include "services/speedlimitservice/speedlimitservice_common.h"

/*!
 * \trace SPEC-4980240
 */
namespace services {
namespace speedlimitservice {

/*!
 * \trace SPEC-4980242
 */
namespace proxy {

/*!
 * \trace SPEC-4980244
 */
namespace methods {

}  // namespace methods

/*!
 * \trace SPEC-4980243
 */
namespace events {

/*!
 * \brief Type alias for service event 'SpeedOverLimitEvent', that is part of the proxy.
 *
 * \trace SPEC-4980345
 */

using SpeedOverLimitEvent =
    ::amsr::socal::events::ProxyEvent<::datatypes::OverLimitEnum, ::amsr::socal::kRuntimeProcessingMode>;

}  // namespace events

/*!
 * \trace SPEC-4980245
 */
namespace fields {

}  // namespace fields

/*!
 * \brief Proxy class for the service 'SpeedLimitService'.
 * \vpublic
 *
 * \trace SPEC-4980344
 * \unit Socal::Proxy::Proxy
 * \complexity The generated proxy class may contain multiple Field, Methods or Events. This
 *             eventually heading towards an increased number of inter unit calls.
 *             No risk identified, since the same code snippet is replicated for each configuration element.
 */
class SpeedLimitServiceProxy : public ::amsr::socal::ThreadDrivenProxy<services::speedlimitservice::SpeedLimitService, services::speedlimitservice::internal::SpeedLimitServiceProxyBackendInterface, services::speedlimitservice::internal::SpeedLimitServiceHandleType>{
 public:

  /*!
   * \brief Type alias for the ProxyBackendInterface.
   */
  using ProxyBackendInterface = services::speedlimitservice::internal::SpeedLimitServiceProxyBackendInterface;

  // ==================== Constructors / Destructors (start) ====================

  /*!
   * \brief Exception-less pre-construction of SpeedLimitServiceProxy.
   *
   * \param[in] handle The identification of the service the proxy should represent. Handles are generated by
   *                   synchronous SpeedLimitServiceProxy::FindService or
   *                   asynchronous SpeedLimitServiceProxy::StartFindService.
   *                   The handle object passed as a parameter shall be a handle returned by a FindService call for this
   *                   specific service.
   *
   * \return Result<ConstructionToken> Result containing construction token from which a proxy object can be
   *                                   constructed.
   * \pre "Runtime" must be initialized.
   * \pre The instance identifier of the \p handle must be known.
   * \pre The proxy backend must be spawned.
   * \pre The provided \p handle must match the handle of the service.
   *
   * \context App
   * \threadsafe FALSE
   * \reentrant FALSE
   * \vpublic
   * \synchronous TRUE
   * \trace SPEC-8053550, SPEC-8053560
   * \steady FALSE
   */
  static ConstructionResult Preconstruct(HandleType const& handle) noexcept;

  /*!
   * \brief   Exception-less constructor of SpeedLimitServiceProxy.
   * \details Handles exception-less construction of a proxy based on the availability of
   *          a valid token.
   * \param[in] token  ConstructionToken created with "Preconstruct()" API.
   * \pre         IAM access must be granted.
   * \context     App
   * \threadsafe  FALSE
   * \reentrant   FALSE
   * \synchronous TRUE
   * \vpublic
   * \steady FALSE
   *
   * \trace SPEC-8053550
   */
  explicit SpeedLimitServiceProxy(ConstructionToken&& token) noexcept;

  /*!
   * \brief Constructor of SpeedLimitServiceProxy. Constructor takes a handle returned by
   * SpeedLimitServiceProxy::FindService() method or provided as parameter to the callback handler of
   * SpeedLimitServiceProxy::StartFindService().
   *
   * \remark Proxy instances created by the application must be destroyed before calling the 
   *         ara::core::Deinitialize() API. Any violations to this will lead to process termination 
   *         through ara::core::Abort().
   *
   * \param[in] handle The identification of the service the proxy should represent. Handles are generated by
   *                   synchronous SpeedLimitServiceProxy::FindService or
   *                   asynchronous SpeedLimitServiceProxy::StartFindService.
   *                   The handle object passed as a parameter shall be a handle returned by a FindService call for this
   *                   specific service.
   *
   * \pre "Runtime" must be initialized.
   * \pre The instance identifier of the \p handle must be known.
   * \pre The proxy backend must be spawned.
   * \pre The provided \p handle must match the handle of the service.
   * \pre IAM access must be granted.
   * \context App
   * \steady FALSE
   * \threadsafe FALSE
   * \reentrant FALSE
   * \vpublic
   * \synchronous TRUE
   * \trace SPEC-4980371
   */
  explicit SpeedLimitServiceProxy(HandleType const& handle) noexcept;

  /*!
   * \brief Delete the copy constructor.
   */
  SpeedLimitServiceProxy(SpeedLimitServiceProxy const&) noexcept = delete;

  /*!
   * \brief Delete the move constructor.
   */
  SpeedLimitServiceProxy(SpeedLimitServiceProxy&&) noexcept = delete;

  /*!
   * \brief Delete the copy assignment operator.
   */
  SpeedLimitServiceProxy& operator=(SpeedLimitServiceProxy const&) & noexcept = delete;

  /*!
   * \brief Delete the move assignment operator.
   */
  SpeedLimitServiceProxy& operator=(SpeedLimitServiceProxy&&) & noexcept = delete;

  /*!
   * \brief   Perform cleanup of proxy instance.
   * \details Unsubscribes all event and field notifications and unsets event receive and subscription state change
   *          handlers. Finally, unregisters the proxy from the communication middleware.
   *          This call will be blocked until all current events/methods' callbacks are finished/canceled.
   * \pre         -
   * \context     App
   * \threadsafe  FALSE for same class instance, TRUE for different instances.
   * \reentrant   FALSE for same class instance, TRUE for different instances.
   * \synchronous TRUE
   * \vpublic
   * \steady FALSE
   * \spec requires true; \endspec
   */
  virtual ~SpeedLimitServiceProxy() noexcept;

  // ===================== Constructors / Destructors (end) =====================

 private:
  /*!
   * \brief Type alias for the base class.
   */
  using Base = ::amsr::socal::ThreadDrivenProxy<services::speedlimitservice::SpeedLimitService, ProxyBackendInterface, services::speedlimitservice::internal::SpeedLimitServiceHandleType>;

  /*!
   * \brief Make GetFutureExecutorInstance() function from Base class as private, to prevent unintended access and
   *        modification of the returned alias by the user code.
   */
  using Base::GetFutureExecutorInstance;

 public:
  // ---- Methods --------------------------------------------------------------------------------------------------

  // ---- Events ---------------------------------------------------------------------------------------------------

  // VECTOR NC VectorC++-V11.0.2: MD_SOCAL_V11-0-2_public_member_in_generated_code
  /*!
   * \brief Event 'SpeedOverLimitEvent' which can be used by application developer.
   * \details
   * Data of type ::datatypes::OverLimitEnum 
   * \vpublic
   * \spec requires true; \endspec
   */
  events::SpeedOverLimitEvent SpeedOverLimitEvent;

  // ---- Fields ---------------------------------------------------------------------------------------------------
};

}  // namespace proxy
}  // namespace speedlimitservice
}  // namespace services

#endif  // WARNINGDISPLAYEXECUTABLE_INCLUDE_SERVICES_SPEEDLIMITSERVICE_SPEEDLIMITSERVICE_PROXY_H_

